# Pitfall 3: Thinking in Lifecycles

```jsx
class LifecycleComponent extends React.Component {
  constructor() {
    // initialize component instance
  }
  componentDidMount() {
    // run this code when the component is first added to the page
  }
  componentDidUpdate(prevProps, prevState) {
    // run this code when the component is updated on the page
  }
  componentWillUnmount() {
    // run this code when the component is removed from the page
  }
  render() {
    // call me anytime you need some react elements...
  }
}
```

```jsx
function HookComponent() {
  React.useEffect(() => {
    // This side effect code is here to synchronize the state of the world
    // with the state of this component.
    return function cleanup() {
      // And I need to cleanup the previous side-effect before running a new one
    }
    // So I need this side-effect and it's cleanup to be re-run...
  }, [when, any, ofThese, change])
  React.useEffect(() => {
    // this side effect will re-run on every single time this component is
    // re-rendered to make sure that what it does is never stale.
  })
  React.useEffect(() => {
    // this side effect can never get stale because
    // it legitimately has no dependencies
  }, [])
  return /* some beautiful react elements */
}
```

> The question is not "when does this effect run" the question is "with which
> state does this effect synchronize with"
>
> ```
> useEffect(fn) // all state
> useEffect(fn, []) // no state
> useEffect(fn, [these, > states])
> ```
>
> - [Ryan Florence](https://twitter.com/ryanflorence/status/1125041041063665666)

---

Let's play find the bug üîç üêù:

```jsx
class DogInfo extends React.Component {
  state = {dog: null}
  // we'll ignore error/loading states for brevity
  componentDidMount() {
    getDog(this.props.dogId).then(dog => {
      this.setState({dog})
    })
  }
  render() {
    return <div>{/* render dog's info */}</div>
  }
}
```

<!--



#SpoilerAlert!



-->

That's right! We're not handling the `dogId` changing! Let's do that...

```jsx
class DogInfo extends React.Component {
  state = {dog: null}
  fetchDog() {
    getDog(this.props.dogId).then(dog => {
      this.setState({dog})
    })
  }
  componentDidMount() {
    this.fetchDog()
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dogId !== this.props.dogId) {
      this.fetchDog()
    }
  }
  render() {
    return <div>{/* render dog's info */}</div>
  }
}
```

But there's another bug üêú! Can you find it?

<!--



#SpoilerAlert!



-->

Yup! What happens if the component unmounts before the request finishes?

> Warning: Can't call setState (or forceUpdate) on an unmounted component. This
> is a no-op, but it indicates a memory leak in your application. To fix, cancel
> all subscriptions and asynchronous tasks in the componentWillUnmount method.

```jsx
class DogInfo extends React.Component {
  controller = null
  state = {dog: null}
  fetchDog() {
    this.controller = new AbortController()
    getDog(this.props.dogId, {signal: this.controller.signal})
      .then(dog => {
        this.setState({dog})
      })
      .catch(e => {
        // handle the error
      })
  }
  componentDidMount() {
    this.fetchDog()
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dogId !== this.props.dogId) {
      this.fetchDog()
    }
  }
  componentWillUnmount() {
    this.controller.abort()
  }
  render() {
    return <div>{/* render dog's info */}</div>
  }
}
```

But there's still another bug üêõ!!!! Can you find it?

<!--



#SpoilerAlert!



-->

Yup! What if the `dogId` changes before the request finishes? Same problem üò¢

```jsx
class DogInfo extends React.Component {
  controller = null
  state = {dog: null}
  fetchDog() {
    if (this.controller) {
      this.controller.abort()
    }
    this.controller = new AbortController()
    getDog(this.props.dogId, {signal: this.controller.signal})
      .then(dog => {
        this.setState({dog})
      })
      .catch(e => {
        // handle the error
      })
  }
  componentDidMount() {
    this.fetchDog()
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dogId !== this.props.dogId) {
      this.fetchDog()
    }
  }
  componentWillUnmount() {
    if (this.controller) {
      this.controller.abort()
    }
  }
  render() {
    return <div>{/* render dog's info */}</div>
  }
}
```

Phew, glad we squashed all those üòå...

ü§î Hmm... What would this look like with Hooks if we still thought about
lifecycles?

```jsx
function DogInfo({dogId}) {
  const controllerRef = React.useRef(null)
  const [dog, setDog] = React.useState(null)
  function fetchDog() {
    if (controllerRef.current) {
      controllerRef.current.abort()
    }
    controllerRef.current = new AbortController()
    getDog(dogId, {signal: controllerRef.current.signal})
      .then(d => setDog(d))
      .catch(e => {
        // handle the error
      })
  }
  // didMount
  React.useEffect(() => {
    fetchDog()
  }, [])

  // didUpdate
  const previousDogId = usePrevious(dogId)
  useUpdate(() => {
    if (previousDogId !== dogId) {
      fetchDog()
    }
  })

  // willUnmount
  React.useEffect(() => {
    return () => {
      if (controllerRef.current) {
        controllerRef.current.abort()
      }
    }
  }, [])

  return <div>{/* render dog's info */}</div>
}
```

And what if we didn't... What if we forgot about lifecycles, and thought instead
about synchronizing side-effects with state?

```jsx
function DogInfo({dogId}) {
  const [dog, setDog] = React.useState(null)
  React.useEffect(() => {
    const controller = new AbortController()
    getDog(dogId, {signal: controller.signal})
      .then(d => setDog(d))
      .catch(e => {
        // handle the error
      })
    return () => controller.abort()
  }, [dogId])

  return <div>{/* render dog's info */}</div>
}
```
