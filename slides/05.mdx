# Pitfall 4: Overthinking performance

```jsx
class LifecycleComponent extends React.Component {
  constructor() {
    // initialize component instance
  }
  componentDidMount() {
    // run this code when the component is first added to the page
  }
  componentDidUpdate(prevProps, prevState) {
    // run this code when the component is updated on the page
  }
  componentWillUnmount() {
    // run this code when the component is removed from the page
  }
  render() {
    // call me anytime you need some react elements...
  }
}
```

```jsx
function HookComponent() {
  React.useEffect(() => {
    // This side effect code is here to synchronize the state of the world
    // with the state of this component.
    return function cleanup() {
      // And I need to cleanup the previous side-effect before running a new one
    }
    // So I need this side-effect and it's cleanup to be re-run...
  }, [when, any, ofThese, change])
  React.useEffect(() => {
    // this side effect will re-run on every single time this component is
    // re-rendered to make sure that what it does is never stale.
  })
  React.useEffect(() => {
    // this side effect can never get stale because
    // it legitimately has no dependencies
  }, [])
  return /* some beautiful react elements */
}
```

> The question is not "when does this effect run" the question is "with which
> state does this effect synchronize with"
>
> ```
> useEffect(fn) // all state
> useEffect(fn, []) // no state
> useEffect(fn, [these, > states])
> ```
>
> - [Ryan Florence](https://twitter.com/ryanflorence/status/1125041041063665666)

---

Let's play find the bug üîç üêù:

```jsx
class DogInfo extends React.Component {
  state = {dog: null}
  // we'll ignore error/loading states for brevity
  componentDidMount() {
    getDog(this.props.dogId).then(dog => {
      this.setState({dog})
    })
  }
  render() {
    return <div>{/* Here I'll render the dog's info */}</div>
  }
}
```

<!--

#SpoilerAlert!

-->

```jsx
class DogInfo extends React.Component {
  state = {dog: null}
  fetchDog() {
    getDog(this.props.dogId).then(dog => {
      this.setState({dog})
    })
  }
  componentDidMount() {
    this.fetchDog()
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dogId !== this.props.dogId) {
      this.fetchDog()
    }
  }
  render() {
    return <div>{/* Here I'll render the dog's info */}</div>
  }
}
```

But there's another bug üêú! Can you find it?

<!--

#SpoilerAlert!

-->

```jsx
class DogInfo extends React.Component {
  controller = null
  state = {dog: null}
  fetchDog() {
    this.controller = new AbortController()
    getDog(this.props.dogId, {signal: this.controller.signal})
      .then(dog => {
        this.setState({dog})
      })
      .catch(e => {
        // handle the error
      })
  }
  componentDidMount() {
    this.fetchDog()
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dogId !== this.props.dogId) {
      this.fetchDog()
    }
  }
  componentWillUnmount() {
    this.controller.abort()
  }
  render() {
    return <div>{/* Here I'll render the dog's info */}</div>
  }
}
```

But there's still another bug üêõ!!!! Can you find it?

<!--

#SpoilerAlert!

-->

```jsx
class DogInfo extends React.Component {
  controller = null
  state = {dog: null}
  fetchDog() {
    if (this.controller) {
      this.controller.abort()
    }
    this.controller = new AbortController()
    getDog(this.props.dogId, {signal: this.controller.signal})
      .then(dog => {
        this.setState({dog})
      })
      .catch(e => {
        // handle the error
      })
  }
  componentDidMount() {
    this.fetchDog()
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dogId !== this.props.dogId) {
      this.fetchDog()
    }
  }
  componentWillUnmount() {
    this.controller.abort()
  }
  render() {
    return <div>{/* Here I'll render the dog's info */}</div>
  }
}
```
