# Pitfall 3: Thinking in Lifecycles

```jsx
class DogInfo extends React.Component {
  controller = null
  state = {dog: null}
  // we'll ignore error/loading states for brevity
  fetchDog() {
    if (this.controller) {
      this.controller.abort()
    }
    this.controller = new AbortController()
    getDog(this.props.dogId, {signal: this.controller.signal})
      .then(dog => {
        this.setState({dog})
      })
      .catch(e => {
        // handle the error
      })
  }
  componentDidMount() {
    this.fetchDog()
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dogId !== this.props.dogId) {
      this.fetchDog()
    }
  }
  componentWillUnmount() {
    if (this.controller) {
      this.controller.abort()
    }
  }
  render() {
    return <div>{/* render dog's info */}</div>
  }
}
```

Let's refactor this to hooks!

```jsx
function DogInfo({dogId}) {
  const controllerRef = React.useRef(null)
  const [dog, setDog] = React.useState(null)
  function fetchDog() {
    if (controllerRef.current) {
      controllerRef.current.abort()
    }
    controllerRef.current = new AbortController()
    getDog(dogId, {signal: controllerRef.current.signal})
      .then(d => setDog(d))
      .catch(e => {
        // handle the error
      })
  }
  // didMount
  React.useEffect(() => {
    fetchDog()
  }, [])

  // didUpdate
  const previousDogId = usePrevious(dogId)
  useUpdate(() => {
    if (previousDogId !== dogId) {
      fetchDog()
    }
  })

  // willUnmount
  React.useEffect(() => {
    return () => {
      if (controllerRef.current) {
        controllerRef.current.abort()
      }
    }
  }, [])

  return <div>{/* render dog's info */}</div>
}
```

ðŸ˜¬ Huh... And... why do we need hooks again?

What if we forgot about lifecycles, and thought instead about synchronizing
side-effects with state?

```jsx
function DogInfo({dogId}) {
  const [dog, setDog] = React.useState(null)
  React.useEffect(() => {
    const controller = new AbortController()
    getDog(dogId, {signal: controller.signal})
      .then(d => setDog(d))
      .catch(e => {
        // handle the error
      })
    return () => controller.abort()
  }, [dogId])

  return <div>{/* render dog's info */}</div>
}
```

So if React doesn't give me lifecycles, what is useEffect for really? Effects
give you a mechanism for:

**synchronizing the state of the world with the state of your component**

```jsx
function HookComponent() {
  React.useEffect(() => {
    // This side effect code is here to synchronize the state of the world
    // with the state of this component.
    return function cleanup() {
      // And I need to cleanup the previous side-effect before running a new one
    }
    // So I need this side-effect and it's cleanup to be re-run...
  }, [when, any, ofThese, change])
  React.useEffect(() => {
    // this side effect will re-run on every single time this component is
    // re-rendered to make sure that what it does is never stale.
  })
  React.useEffect(() => {
    // this side effect can never get stale because
    // it legitimately has no dependencies
  }, [])
  return /* some beautiful react elements */
}
```

> The question is not "when does this effect run" the question is "with which
> state does this effect synchronize with"
>
> ```
> useEffect(fn) // all state
> useEffect(fn, []) // no state
> useEffect(fn, [these, states])
> ```
>
> - [Ryan Florence](https://twitter.com/ryanflorence/status/1125041041063665666)
